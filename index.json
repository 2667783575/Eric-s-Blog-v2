[{"content":"","date":"30 September 2025","externalUrl":null,"permalink":"/Eric-s-Blog-v2/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"30 September 2025","externalUrl":null,"permalink":"/Eric-s-Blog-v2/","section":"Erics Blog","summary":"","title":"Erics Blog","type":"page"},{"content":"","date":"30 September 2025","externalUrl":null,"permalink":"/Eric-s-Blog-v2/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"30 September 2025","externalUrl":null,"permalink":"/Eric-s-Blog-v2/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":" 博客迁移 # 本来这两天又是写前后端又是学rust的，感觉需要写两篇博客记录一下成长了，结果突然发现老博客拓展性太差了，刚好发现blowfish这个更智能，更强大的基于hugo的博客框架，于是干脆按照blowfish上的j教程重新配置了一遍，然后将原来博客的内容全部迁移到新博客了。\nblowfish yyds\n猛猛推荐了\n","date":"30 September 2025","externalUrl":null,"permalink":"/Eric-s-Blog-v2/posts/1759232950429-post13/","section":"Posts","summary":"","title":"博客2.0启动","type":"posts"},{"content":"","date":"30 September 2025","externalUrl":null,"permalink":"/Eric-s-Blog-v2/tags/%E5%A4%8F%E5%AD%A3%E5%85%AB%E6%AD%A3/","section":"Tags","summary":"","title":"夏季八正","type":"tags"},{"content":"","date":"30 September 2025","externalUrl":null,"permalink":"/Eric-s-Blog-v2/categories/%E6%8A%98%E8%85%BE/","section":"Categories","summary":"","title":"折腾","type":"categories"},{"content":"","date":"30 September 2025","externalUrl":null,"permalink":"/Eric-s-Blog-v2/tags/example/","section":"Tags","summary":"","title":"Example","type":"tags"},{"content":"an example to get you started\nThis is a heading # This is a subheading # This is a subsubheading # This is a subsubsubheading # This is a paragraph with bold and italic text. Check more at Blowfish documentation undefined\n","date":"30 September 2025","externalUrl":null,"permalink":"/Eric-s-Blog-v2/posts/1759239394060-post14/","section":"Posts","summary":"","title":"post14","type":"posts"},{"content":"","date":"30 September 2025","externalUrl":null,"permalink":"/Eric-s-Blog-v2/tags/tag/","section":"Tags","summary":"","title":"Tag","type":"tags"},{"content":"","date":"12 September 2025","externalUrl":null,"permalink":"/Eric-s-Blog-v2/tags/%E5%93%B2%E6%80%9D/","section":"Tags","summary":"","title":"哲思","type":"tags"},{"content":"","date":"12 September 2025","externalUrl":null,"permalink":"/Eric-s-Blog-v2/tags/%E5%B0%8F%E4%BA%8B/","section":"Tags","summary":"","title":"小事","type":"tags"},{"content":"","date":"12 September 2025","externalUrl":null,"permalink":"/Eric-s-Blog-v2/categories/%E6%97%A5%E5%B8%B8%E5%93%B2%E6%80%9D/","section":"Categories","summary":"","title":"日常哲思","type":"categories"},{"content":" 事件概述 # 大抵是先前参加数模竞赛的时候表现的比较有技术力和责任心，两个队友是大三的学长和学姐。完赛以后，学长来找我，说想把他的大创项目传给我。\n我大概了解了一下，学长这个大创项目是去年搞的，选题很突出，弄了很多研究生研发了一个学期，最后做的非常优秀，拿下了省级特等奖并且顺理成章的变成了国家级立项项目，听起来就是一个十分优秀的大创。并且现在已经比较成熟，学长希望我来接盘这个项目，做这个项目的全权领导人，并在这个项目的基础上去打互联网+，挑战杯等竞赛，拿下更多成果。\n作为学弟，受到学长如此信赖，这当然使我倍感荣幸。\n世上之事大约皆为利益驱动，没有人会无缘无故的给你好处，就像天上不会掉下馅饼 # 然而，在我看来，学长分外热情的表现大抵不完全是因为我的优秀本身。更多也许是学长已经大三了，想要成果又不想把经历分在大创竞赛上，因此让我来做核心来推动项目继续运作。这样学长既不需要付出时间和精力，又可以坐收渔翁之利。五个人的大创核心团队，学长和一个成员占两位，然后我要负责招兵买马填充其他位置和组织整个项目的发展。\n这个主题在这件事上就很明显，学长招我进去一定是对他有利的，只要push我就可以让项目发展下去，如果拿下互联网+等竞赛成果，什么也不用做的学长就可以捞得项目后期的成果。我们必须在遇到这些事时认真的想想背后的缘故。\n双赢还是单输 # 前面已经说了，任何人(也许除了亲人？)做事都是符合他的利益的。而当你要被卷入他的盈利时就要想一想，你的加入是双赢还是单方面的被吸血。\n在这一点上，我想我加入的不确定性太大了。首先这是一个已经有了的项目，他的团队是否会承认一个半途加入的leader？那些学长拉拢进去的研究生是否会听你的话呢？如果需要投钱投资源，你投吗？或者说投进去值得吗？如果能够拿下大奖的话，当然对我和学长来说是win-win的，然而如果不能呢？那我就会成为背锅侠，并且付出时间和精力的代价。\n互联网+竞赛对于我而言不是必选项，所以接受这个项目对我的实质性好处是很有限的。我可以用更多的时间去做更有价值的事情。\n和情商高的人交流 # 综上原因，我礼貌但是不留余地拒绝了学长。学长表现的也很坦然，并表示了对我的祝福。\n这又让我想到去年时另一个学长了。\n情商的高低真的会决定很多事的。\n去年是在OODP课上，老师随机分组做期末大作业。由于课难度很大，讲的还很差，后期还在听课的人很少。我们五人小组里有我和一个同级元班学生和一个物联网专业的学长（另外两个人干脆从头到尾没有出现）。虽然那个学长比我大一级，但是他什么都不会。期中时曾来找我问环境配置的问题，我教了他以后他一句谢谢也没说就走了。后来期末的时候他又跟我说让我带带他，我说不行，如果你有能力，我们就一块做。如果你做不了，那我就自己做，你可以再找其他同学一块做，或者你换个组也行（因为我真的特别讨厌什么都不干的人白混到学分）。谁知他竟恼羞成怒，直接在微信上骂我，还各种阴阳怪气，说原来你们计院的同学都这么牛逼啊，那我带着其他几个同学做，你自己玩去吧。（实际上正合我意，组里本来就三个活人，另外两个还啥都不会，我自己单干效率还真是更高）。最后他见骂我我居然不为所动，其他几个同学也根本动员不起来，才又厚着脸皮让我留下他。最后我直接把他踢出去了。\n元班那个同学也是什么都不会，代码全部用ai生成，甚至放到word里面交给我。但是他说话特别有水平，态度也很好。最后就跟着我混了过去（在我的推荐下老师给了他90分）。\n相比之下，和情商高的人交流，即便你们的合作没有谈成，甚至有些冲突，最后也会给彼此台阶下。也许多年以后还有合作的可能，还能互相帮助。\n而像物联网专业的那个学长，那般情商和道德水平，也许谈不拢就要开骂，最后惨淡收场，失去本可以留下的人脉。\n也许做人比做事更重要吧\n","date":"12 September 2025","externalUrl":null,"permalink":"/Eric-s-Blog-v2/posts/1759232945319-post12/","section":"Posts","summary":"","title":"记一件小事","type":"posts"},{"content":"","date":"2 September 2025","externalUrl":null,"permalink":"/Eric-s-Blog-v2/tags/python/","section":"Tags","summary":"","title":"Python","type":"tags"},{"content":" trs # 今天花了几个小时从零折腾一些库，开发了一个python翻译工具脚本，当读入单词时请求bing网页再用bs处理得到词的解释，当读入句子时请求大模型得到智能翻译，并使用rich库美化了输出。\n仓库地址\n并且从中学习到了python脚本如何转换为系统自动调用python运行的脚本\n即在python脚本头添加shebang头，然后将python脚本的名称中的.py删去即可\n二次开发 # 2025/9/3 11:43\n在群友的建议下，晚上又花了一些时间在不影响原本功能的情况下添加了复制和保存功能\n","date":"2 September 2025","externalUrl":null,"permalink":"/Eric-s-Blog-v2/posts/1759232939643-post11/","section":"Posts","summary":"","title":"trs","type":"posts"},{"content":"","date":"2 September 2025","externalUrl":null,"permalink":"/Eric-s-Blog-v2/tags/%E5%B0%8F%E4%B8%9C%E8%A5%BF/","section":"Tags","summary":"","title":"小东西","type":"tags"},{"content":"","date":"2 September 2025","externalUrl":null,"permalink":"/Eric-s-Blog-v2/categories/%E5%BC%80%E5%8F%91/","section":"Categories","summary":"","title":"开发","type":"categories"},{"content":"","date":"31 August 2025","externalUrl":null,"permalink":"/Eric-s-Blog-v2/tags/c%23/","section":"Tags","summary":"","title":"C#","type":"tags"},{"content":"","date":"31 August 2025","externalUrl":null,"permalink":"/Eric-s-Blog-v2/tags/oodp/","section":"Tags","summary":"","title":"OODP","type":"tags"},{"content":" 提供一个简明的 API 来逐步构建一个复杂对象，将其构建过程与它的表示分离开。 # 引入 # 先来看一段C#自带的Builder模式的应用\nStringBuilder\n假设我们想要构建Html元素\nstatic void Main(string[] args) { var hello = \u0026#34;hello\u0026#34;; var sb = new StringBuilder(); sb.Append(\u0026#34;\u0026lt;p\u0026gt;\u0026#34;); sb.Append(hello); sb.Append(\u0026#34;\u0026lt;/p\u0026gt;\u0026#34;); Console.WriteLine(sb.ToString()); sb.Clear(); var words = new[] { \u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34; }; sb.Append(\u0026#34;\u0026lt;ul\u0026gt;\u0026#34;); foreach (var word in words) { sb.AppendFormat(\u0026#34;\u0026lt;li\u0026gt;{0}\u0026lt;li\u0026gt;\u0026#34;, word); } sb.Append(\u0026#34;\u0026lt;/ul\u0026gt;\u0026#34;); Console.WriteLine(sb.ToString()); } 我们现在想要写一个HtmlElement类将Html元素封装起来，它需要能够包含标签名，文本和子元素。\npublic class HtmlElement { public string Name, Text; public List\u0026lt;HtmlElement\u0026gt; Elements = []; public HtmlElement() { } public HtmlElement(string name, string text) { Name = name ?? throw new ArgumentNullException(nameof(name)); Text = text ?? throw new ArgumentNullException(nameof(text)); } } 然后我们希望HtmlElement可以优雅的转换为字符串（应包含缩进）\n// 在 HtmlElement 类中 private const int IndentSize = 2; // 定义缩进为两个空格 private string ToStringImpl(int indent) { var sb = new StringBuilder(); var i = new string(\u0026#39; \u0026#39;, indent * IndentSize); sb.AppendLine($\u0026#34;{i}\u0026lt;{Name}\u0026gt;\u0026#34;); if (!string.IsNullOrEmpty(Text)) { sb.Append(new string(\u0026#39; \u0026#39;, (indent+1) * IndentSize)); sb.AppendLine(Text); } foreach (var e in Elements) { string s = e.ToStringImpl(indent + 1); sb.Append(s); } sb.AppendLine($\u0026#34;{i}\u0026lt;/{Name}\u0026gt;\u0026#34;); return sb.ToString(); } //使用递归DFS实现了元素的字符串输出 public override string ToString() { return ToStringImpl(0); } 我们仍然不满意，还想要一个更简单的构建方式，于是我们自己写一个HtmlBuilder类\nHtmlBuilder # 考虑HtmlBuilder应该以一个根元素为基础，可以添加子元素，可以清空子元素\npublic class HtmlBuilder { private readonly string rootName; private HtmlElement _root = new HtmlElement(); public HtmlBuilder(string rootName) { this.rootName = rootName ?? throw new ArgumentNullException(nameof(rootName)); _root.Name = rootName ?? throw new ArgumentNullException(nameof(rootName)); } public void AddChild(string childName ,string childText) { var e = new HtmlElement(childName, childText); _root.Elements.Add(e); } public override string ToString() { return _root.ToString(); } public void Clear() { _root = new HtmlElement{Name = rootName}; } } 上述代码中专门保留rootName是因为我们希望Clear()后仍然保持其根元素\n调用\npublic class Demo { static void Main(string[] args) { var builder = new HtmlBuilder(\u0026#34;ul\u0026#34;); builder.AddChild(\u0026#34;li\u0026#34;,\u0026#34;hello\u0026#34;); builder.AddChild(\u0026#34;li\u0026#34;,\u0026#34;world\u0026#34;); Console.WriteLine(builder.ToString()); } } 我们就得到了较为美观的输出\n\u0026lt;ul\u0026gt; \u0026lt;li\u0026gt; hello \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt; world \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; 流构建器 # 注意到StringBuilder可以使用一种Fluent Interface Pattern的流调用方法 如\nsb.Append(\u0026#34;a\u0026#34;).Append(\u0026#34;b\u0026#34;).Append(\u0026#34;c\u0026#34;); 我们希望我们的HtmlBuilder也具有这样的功能，只需要\npublic HtmlBuilder AddChild(string childName ,string childText) { var e = new HtmlElement(childName, childText); _root.Elements.Add(e); return this; }//将原来的void返回值改为返回对自身的引用即可 于是我们可以这样调用\nbuilder.AddChild(\u0026#34;li\u0026#34;,\u0026#34;hello\u0026#34;).AddChild(\u0026#34;li\u0026#34;,\u0026#34;world\u0026#34;); 流式构建器的继承 # 问题 # 对普通构建者的继承不会引起什么问题，而当使用流式构建者时，问题则棘手起来。\n先来看一个简单的例子，我们有Person类，它具有名字和职位两个属性。同时有一个流构建者只处理名字。\npublic class Person { public string Name; public string Position; public override string ToString() { return $\u0026#34;{nameof(Name)}: {Name}, {nameof(Position)}: {Position}\u0026#34;; } } public class PersonInfoBuilder { protected Person person = new Person(); //这里是protected因为我们一会将处理继承关系 public PersonInfoBuilder Called(string name) { person.Name = name; return this; } } 现在我们有新的业务需求，即现在需要Builder能同时处理职位的构建，我们遵循开闭原则使用新类继承PersonInfoBuilder\npublic class PersonJobBuilder: PersonInfoBuilder { public PersonJobBuilder WorksAsA(string position) { person.Position = position; return this; } } 现在我们尝试调用PersonJobBuilder\n// bad code PersonJobBuilder jb = new PersonJobBuilder(); jb.Called(\u0026#34;Li Bad\u0026#34;).WorksAsA(\u0026#34;Manager\u0026#34;); 注意到这段代码是报错的，原因是Called方法返回的是一个PersonInfoBuilder，而PersonInfoBuilder不能处理职位相关事项，不具备WorksAsA方法\n问题本质： 当 Fluent 方法需要返回 this 时，在继承链中，父类的方法如果返回的是父类类型 (PersonInfoBuilder)，那么子类的方法链就会在调用父类方法后中断，无法继续调用子类的方法。\n解决方案 # 使用递归泛型\n首先我们来创建一个PersonBuilder的抽象类，将Person的存储和Build方法提取到抽象类里。\npublic abstract class PersonBuilder { protected Person person = new Person(); public Person Build() { return person; } } 然后用递归泛型改写PersonInfoBuilder\npublic class PersonInfoBuilder\u0026lt;TSelf\u0026gt; : PersonBuilder where TSelf : PersonInfoBuilder\u0026lt;TSelf\u0026gt; { public TSelf Called(string name) { person.Name = name; return (TSelf)this; } } 理解： 给PersonInfoBuilder添加了一个泛型TSelf，TSelf用来存放子类的类型，于是Called方法就可以通过类型转换return子类的类型，为了保证TSelf一定是子类的类型，我们用where语句限制TSelf继承于该类。\n我们可能下意识这样使用\n// bad code public class PersonJobBuilder: PersonInfoBuilder\u0026lt;PersonJobBuilder\u0026gt; { public PersonJobBuilder WorksAsA(string position) { person.Position = position; return this; } } 但是假想如果有类又继承PersonJobBuilder的话，由于PersonJobBuilder被固定，继承PersonJobBuilder的类又将不能正确工作。因此这决不是一个好注意。\n正确的写法应该是在PersonJobBuilder上继续泛型\npublic class PersonJobBuilder\u0026lt;TSelf\u0026gt; : PersonInfoBuilder\u0026lt;PersonJobBuilder\u0026lt;TSelf\u0026gt;\u0026gt; where TSelf : PersonJobBuilder\u0026lt;TSelf\u0026gt; { public TSelf WorksAsA(string position) { person.Position = position; return (TSelf)this; } } 理解： PersonJobBuilder也具有类型TSelf的泛型，也用where限制TSelf继承于该类，同时PersonJobBuilder中的泛型从PersonJobBuilder改为PersonJobBuilder，仅此而已\n当我们高兴的尝试使用PersonJobBuilder时，我们发现PersonJobBuilder并不能直接构建。这样的泛型类都不能直接使用，必须用一个类继承泛型类，才能使用。\n所以我们在Person中写一个Builder类，它继承于PersonJobBuilder\u0026lt;Person.Builder\u0026gt;，同时给Person类添加相应的构建方法\n// 在Person类内 public class Builder:PersonJobBuilder\u0026lt;Builder\u0026gt; { } public static Builder New =\u0026gt; new Builder(); 于是我们现在可以调用\nvar person = Person.New. Called(\u0026#34;Wang\u0026#34;). WorksAsA(\u0026#34;LaoBan\u0026#34;). Build(); Console.WriteLine(person); 得到输出\nName: Wang, Position: LaoBan 分步构建器 # 设想这样一个场景，我们现在要做车的创建者，车子具有类型，小轿车(Sedan)或跨界车(CrossOver)，小轿车的尺寸必须在15到17之间，而跨界车必须在17-20之间，如果超出范围就要报错。\n我们注意到该构建过程具有明显的分步性，必须先知道类型，才能判断尺寸，这就引出了分步构建者\n先定义车类\npublic enum CarType { Sedan, Crossover } public class Car { public CarType type; public int WheelSize; } 应用接口隔离原则我们将车的构建过程分成几个独立的接口\npublic interface ISpecifyCarType { ISpecifyWheelSize OfType(CarType type); } public interface ISpecifyWheelSize { IBuildCar WithWheels(int size); } public interface IBuildCar { public Car Build(); } 其中ISpecifyCarType用来指定车的类型，它随后返回一个ISpecifyWheelSize接口进一步指定车的轮子尺寸，再返回IBuildCar进一步构建车对象\n在CarBuilder类中，我们将构建过程的实现封装到Impl里\npublic class CarBuilder { private class Impl:ISpecifyWheelSize,ISpecifyCarType,IBuildCar { private Car _car = new Car(); public ISpecifyWheelSize OfType(CarType type) { _car.type = type; // work as ISpecifyCarType return this; // this is ISpecifyWheelSize } public IBuildCar WithWheels(int size) { switch (_car.type) { case CarType.Crossover when size is \u0026lt; 17 or \u0026gt; 20: case CarType.Sedan when size is \u0026lt; 15 or \u0026gt; 17: throw new ArgumentException(\u0026#34;Car size out of range\u0026#34;); default: break; } _car.WheelSize = size; // work as ISpecifyWheelSize return this; // this is IBuildCar } public Car Build() { return _car; } } public static ISpecifyCarType Create() { return new Impl(); } } 注意到上述Impl类同时实现了ISpecifyWheelSize,ISpecifyCarType,IBuildCar三个接口，所以它只需要不停return this就可以让构建过程不断递进。\n使用如下\nvar car = CarBuilder.Create().OfType(CarType.Sedan).WithWheels(20).Build(); 函数式构建器 # 我们可以使用函数式的方式来构造一个PersonBuilder类，我们让它存储下我们想要对对象进行的所有操作的列表，然后在Build时再对初始对象进行所有这些操作并返回\npublic sealed class PersonBuilder { private List\u0026lt;Func\u0026lt;Person, Person\u0026gt;\u0026gt; actions = new List\u0026lt;Func\u0026lt;Person, Person\u0026gt;\u0026gt;(); private PersonBuilder AddAction(Action\u0026lt;Person\u0026gt; action) { actions.Add(p=\u0026gt; { action(p); return p; }); return this; } public Person Build() =\u0026gt; actions.Aggregate(new Person(), (acc, action) =\u0026gt; action(acc)); public PersonBuilder Called(string name) =\u0026gt; Do(p =\u0026gt; p.Name = name); public PersonBuilder Do(Action\u0026lt;Person\u0026gt; action)=\u0026gt;AddAction(action); } 我们使用sealed关键字密封该类，强调我们不需要继承就能实现想要的功能。\n那么我们如何不通过继承来添加新的功能呢？\n答案是通过C#的静态拓展方法\npublic static class PersonBuilderExtensions { public static PersonBuilder WorksAsA(this PersonBuilder builder, string position) =\u0026gt; builder.Do(p =\u0026gt; p.Position = position); } 此时我们可以直接使用WorksAsA\nvar person = new PersonBuilder().Called(\u0026#34;Wang\u0026#34;).WorksAsA(\u0026#34;LaoBan\u0026#34;).Build(); 注意到，函数式创建者的工作方式其实都是类似的，所以我们直接将函数式构建者写为泛型，然后再特化使用\npublic abstract class FunctionBuilder\u0026lt;TSubject, TSelf\u0026gt; where TSelf : FunctionBuilder\u0026lt;TSubject, TSelf\u0026gt; where TSubject: new() { private List\u0026lt;Func\u0026lt;TSubject, TSubject\u0026gt;\u0026gt; actions = new List\u0026lt;Func\u0026lt;TSubject, TSubject\u0026gt;\u0026gt;(); private TSelf AddAction(Action\u0026lt;TSubject\u0026gt; action) { actions.Add(p=\u0026gt; { action(p); return p; }); return (TSelf)this; } public TSubject Build() =\u0026gt; actions.Aggregate(new TSubject(), (acc, action) =\u0026gt; action(acc)); public TSelf Do(Action\u0026lt;TSubject\u0026gt; action)=\u0026gt;AddAction(action); } public sealed class PersonBuilder:FunctionBuilder\u0026lt;Person,PersonBuilder\u0026gt; { public PersonBuilder Called(string name)=\u0026gt; Do(p =\u0026gt; p.Name = name); } public static class PersonBuilderExtensions { public static PersonBuilder WorksAsA(this PersonBuilder builder, string position) =\u0026gt; builder.Do(p =\u0026gt; p.Position = position); } 功能仍然不变\n分派构建器 # 我们可以将一个对象的属性分拆成不同的方面，交给不同的构建器负责，最后再封装给一个构建器\n例子 # 比如我们有一个Person类，它具有StreetAddress,Postcode,City等居住地相关属性和CompanyName,Position,AnnualIncome等工作相关属性\npublic class Person { public string? StreetAddress,Postcode,City; public string? CompanyName, Position; public int AnnualIncome; public override string ToString() { return $\u0026#34;{nameof(StreetAddress)}: {StreetAddress}, {nameof(Postcode)}: {Postcode}, {nameof(City)}: {City}, {nameof(CompanyName)}: {CompanyName}, {nameof(Position)}: {Position}, {nameof(AnnualIncome)}: {AnnualIncome}\u0026#34;; } } 然后再写一个PersonBuilder类（该类是一个外壳，并不处理具体构建过程）\npublic class PersonBuilder // facade { protected Person Person = new Person(); } 然后我们写PersonAddressBuilder和PersonJobBuilder两个类继承于PersonBuilder，分别处理地址和工作相关的属性的构建\npublic class PersonAddressBuilder : PersonBuilder { public PersonAddressBuilder(Person person) { Person = person; } public PersonAddressBuilder At(string streetAddress) { Person.StreetAddress = streetAddress; return this; } public PersonAddressBuilder WithPostcode(string postcode) { Person.Postcode = postcode; return this; } public PersonAddressBuilder In(string city) { Person.City = city; return this; } } public class PersonJobBuilder:PersonBuilder { public PersonJobBuilder(Person person) { this.Person = person; } public PersonJobBuilder At(string companyName) { Person.CompanyName = companyName; return this; } public PersonJobBuilder AsA(string position) { Person.Position = position; return this; } public PersonJobBuilder Earning(int amount) { Person.AnnualIncome = amount; return this; } } 将PersonJobBuilder和PersonAddressBuilder的对象作为PersonBuilder的公共属性\npublic class PersonBuilder // facade { protected Person Person = new Person(); public PersonJobBuilder Works =\u0026gt; new PersonJobBuilder(Person); public PersonAddressBuilder Lives =\u0026gt; new PersonAddressBuilder(Person); public static implicit operator Person(PersonBuilder b) =\u0026gt; b.Person; } 上面代码中的operator重载了PersonBuilder向Person的隐式转换，使得PersonBuilder构建对象使用时更方便\n于是我们可以这样使用构建器\nvar pb = new PersonBuilder(); Person person = pb.Works.At(\u0026#34;Huawei\u0026#34;).AsA(\u0026#34;Manager\u0026#34;).Earning(1000000) .Lives.At(\u0026#34;Nanluoguxiang\u0026#34;).In(\u0026#34;Beijing\u0026#34;).WithPostcode(\u0026#34;666\u0026#34;); 总结 # 构建器是用来构建对象的独立的组件 你可以通过构造函数生成构建器，也可以通过静态函数返回构建器 如果要让构建器实现流式接口，只需要return this，如果还要实现继承，使用递归泛型 一个对象的不同方面可以由不同的构建器通过一个基类并联起来 ","date":"31 August 2025","externalUrl":null,"permalink":"/Eric-s-Blog-v2/posts/1759232934070-post10/","section":"Posts","summary":"","title":"OODP6 构造器模式 (Builder)","type":"posts"},{"content":"","date":"31 August 2025","externalUrl":null,"permalink":"/Eric-s-Blog-v2/categories/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/","section":"Categories","summary":"","title":"技术相关","type":"categories"},{"content":" Gamma Categorization # 设计模式通常被分为三类\n这被称为Gamma分类(纪念Erich Gamma)\n创造型模式 Creational Patterns # 处理对象的创建 显示(构造函数)或隐式(依赖注入DI,反射等) 整批的(单语句single statement)或分段的(一步一步地step-by-step) 结构性模式 Structural Patterns # 和结构相关的(如类成员) 许多模式是模仿隐含于它之下的类的接口的包装器 强调良好API设计的重要性 行为型模式 Behavioral Patterns # 没有中心主题 ","date":"31 August 2025","externalUrl":null,"permalink":"/Eric-s-Blog-v2/posts/1759232929063-post9/","section":"Posts","summary":"","title":"OODP5 Gamma分类","type":"posts"},{"content":"","date":"31 August 2025","externalUrl":null,"permalink":"/Eric-s-Blog-v2/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","section":"Tags","summary":"","title":"设计模式","type":"tags"},{"content":" 设计代码结构时，高层模块不应该依赖低层模块，二者都应该依赖其抽象。抽象不应该依赖于细节，细节应该依赖于抽象。 # 错误做法 # 我们看一个简单的例子，设计一个关系存储的模块，共有三种关系(Relationship)，父，子，同辈。\n于是我们给出Relationship枚举和Person类\npublic enum Relationship { Parent, Child, Sibling } public class Person { public string Name; } 开始设计低层模块，记录关系的Relationship类，我们随意的使用tuple来记录各种关系，并简单给出添加关系的api，同时将私有的relations成员通过公有的Relations函数暴露出去\npublic class Relationships { private List\u0026lt;(Person, Relationship,Person)\u0026gt; relations = []; public void AddParentAndChild(Person parent, Person child) { relations.Add((parent, Relationship.Parent, child)); relations.Add((child, Relationship.Child, parent)); } public List\u0026lt;(Person, Relationship, Person)\u0026gt; Relations =\u0026gt; relations; } 于是我们在高层模块中使用直接使用底层模块，即在Demo构造函数中直接接受Relationships作为参数，当我们想要查询John的孩子是谁时，我们遍历通过Relations得到的关系元组进行查询输出即可。\npublic class Demo { public Demo(Relationships relationships) { var relations = relationships.Relations; foreach (var r in relations.Where(x =\u0026gt; x.Item1.Name == \u0026#34;John\u0026#34; \u0026amp;\u0026amp; x.Item2 == Relationship.Parent)) { Console.WriteLine($\u0026#34;John has a child {r.Item3.Name}\u0026#34;); } } static void Main(string[] args) { var parent = new Person(){Name = \u0026#34;John\u0026#34;}; var child1 = new Person(){Name = \u0026#34;Jane\u0026#34;}; var child2 = new Person(){Name = \u0026#34;Jonny\u0026#34;}; var relations = new Relationships(); relations.AddParentAndChild(parent, child1); relations.AddParentAndChild(parent, child2); new Demo(relations); } } 反思环节 # 注意到，当我们这样做时，由于高层直接依赖于低层，低层是“不可拆换的”。\n例如，如果我们不想再使用元组列表作为我们的数据结构，而是想要切换成元组数组，或者直接换成树结构。我们的代码就必须大量重写，不仅要完全重写低层记录关系的类，还得将上层Demo类里直接调用低层类的部分全部重写。\n如果这是一个很大的项目架构，这个低层模块可能被很多个高层模块调用，这将带来巨大的维护代价。\n从DIP中总结，即是高层模块直接依赖低层模块(Demo类直接使用Relationships类)，抽象依赖于细节(“从关系中查找特定人的孩子”的抽象依赖于了元组和遍历这样的实现细节)\n正确操作 # 高层模块不应依赖于低层模块，二者都应该依赖于抽象。那么我们需要一个抽象放在Demo和Relationships之间。\n于是我们给出接口IRelationshipBrowser\npublic interface IRelationshipBrowser { IEnumerable\u0026lt;Person\u0026gt; FindAllChildOf(string person); } 这个接口即为抽象的一种形式，它代表着“关系浏览器”的抽象概念，而不涉及任何它的实现，只说明它应该有找到某人所有孩子的功能。\n于是我们现在可以让高层依赖抽象\n这里参数的类型的正是抽象，而不是底层模块本身。与此同时你可以看到API比原来好看的多。\npublic Demo(IRelationshipBrowser browser) { foreach (var r in browser.FindAllChildOf(\u0026#34;John\u0026#34;)) { Console.WriteLine($\u0026#34;John has a child {r.Name}\u0026#34;); } } 低层模块的实现也依赖接口的抽象，即低层模块必须实现该接口的功能。\n/// public class Relationships : IRelationshipBrowser { private List\u0026lt;(Person, Relationship,Person)\u0026gt; relations = [];\npublic void AddParentAndChild(Person parent, Person child) { relations.Add((parent, Relationship.Parent, child)); relations.Add((child, Relationship.Child, parent)); } public IEnumerable\u0026lt;Person\u0026gt; FindAllChildOf(string person) { var relations = Relations; return relations.Where(x =\u0026gt; x.Item1.Name ==person \u0026amp;\u0026amp; x.Item2 == Relationship.Parent).Select(x =\u0026gt; x.Item3); // low level } public List\u0026lt;(Person, Relationship, Person)\u0026gt; Relations =\u0026gt; relations; }\n这里函数的实现使用了LINQ来简化。 注意到此时相比于之前的代码，当我们想要换一种Relationships，如用树來实现同样的功能时，我们不再需要更改上层模块了。此时只需要写一个类，比如说TreeRelationships，让它实现IRelationshipBrowser接口，在所有上层调用中就可以直接使用TreeRelationships类了（因为上层模块接受所有实现了IRelationshipBrowser的类作为参数）。从直观理解上，上层模块只关心下层提供什么样的服务，所以应只依赖于抽象，这样下层即使更改了服务的提供商，只要能提供目标服务，也能正确地运行。 ","date":"30 August 2025","externalUrl":null,"permalink":"/Eric-s-Blog-v2/posts/1759232901555-post8/","section":"Posts","summary":"","title":"OODP4 依赖倒置原则(DIP)","type":"posts"},{"content":" 不应强迫客户端依赖它不使用的方法 # 该原则过于简单，索性不放代码\n例子 # 一个现代打印机可以打印(Print),传真(Fax),扫描(Scan)，所以我们写了一个接口IMachine，并让它包括这三个功能的函数\n然而，当我们需要创建一个老式打印机时，该打印机只有打印功能，如果实现IMachine接口，Fax和Scan两个函数要么抛出异常，要么打印未实现，这都是非常不好的情况(即我们强迫老式打印机依赖了它不使用的方法)。\n因此我们要把IMachine接口拆分开，如IPrinter,IFaxer,IScanner，以使得客户端需要使用什么方法就实现什么接口。\n和SRP的区别 # 特性 SRP (单一职责原则) ISP (接口隔离原则) 关注点 类的内部凝聚力 - 一个类应该只做一件事 接口的外部耦合 - 一个接口不应该强迫客户端依赖它不需要的方法 主要对象 类（Class） 接口（Interface） 核心思想 只有一个变化原因 不强迫客户接受不需要的方法 解决的问题 类过于庞大、僵化、难以修改 接口臃肿，导致客户端实现不必要的空方法或收到“接口污染” 关系 相辅相成。通常，遵循SRP拆分出的类，自然会拥有更单一、更聚焦的接口。而为了遵循ISP，你常常需要先运用SRP来厘清职责。 ","date":"29 August 2025","externalUrl":null,"permalink":"/Eric-s-Blog-v2/posts/1759232893885-post7/","section":"Posts","summary":"","title":"OODP3 接口隔离原则(ISP)","type":"posts"},{"content":" 父类的对象可以被子类的对象替换，而程序的行为不会发生变化 # 例子 # 我们有Rectangle类\npublic class Rectangle { public int Height{get; set; } public int Width { get; set; } public Rectangle() { } public Rectangle(int width, int height) { Width = width; Height = height; } public override string ToString() { return $\u0026#34;{nameof(Width)}: {Height}, {nameof(Height)}: {Height}\u0026#34;; } } 基于Rectangle类再写Square类\npublic class Square : Rectangle { public new int Width { set { base.Width = base.Height = value; } } public new int Height { set { base.Width = base.Height = value; } } } 注意到我们用new关键字hide了父类的Width和Height\n此时Square和Rectangle都可以正常工作\nRectangle rc = new Rectangle(); rc.Width = 20; rc.Height = 40; Console.WriteLine(\u0026#34;Area: {0}\u0026#34;, Area(rc)); Square sq = new Square(); sq.Width = 4; Console.WriteLine(\u0026#34;Area {0}\u0026#34;, Area(sq)); 可以看到结果正常\n而由于正方形是一种长方形，我们可以使用父类型Rectangle来持有子类型Square的引用。\n那么问题发生了\nRectangle sq = new Square(); sq.Width = 4; Console.WriteLine(\u0026#34;Area {0}\u0026#34;, Area(sq)); 输出: Area 0 这就违反了里氏替换原则，当子类的对象替换父类时发生了错误。\n修改方案 # 将Rectangle中Width和Height的get,set修改为虚，使父类引用执行子类的函数\npublic virtual int Height{get; set; } public virtual int Width { get; set; } 同时将Square中的用new来hide父类型改为用override来重写父类虚函数\npublic override int Width { set { base.Width = base.Height = value; } } public override int Height { set { base.Width = base.Height = value; } } 则现在不会出现错误\n特性 里氏替换原则 (LSP) 虚函数/重写 (virtual/override) 本质 设计原则 (Principle) 语法机制 (Syntax) 目的 指导如何正确地建立继承关系，确保行为兼容性。 实现运行时多态，允许子类定制方法实现。 关系 目标 (What \u0026amp; Why) 主要实现手段 (How) C#, C++和Java的虚函数辨析 # 特性 C# Java 声明可重写方法 使用 virtual 关键字 默认就是“虚”的，无需关键字 重写方法 使用 override 关键字 使用 @Override 注解（最佳实践） 阻止重写 方法不标记为 virtual 使用 final 关键字 隐藏方法（非多态） 使用 new 关键字 无关键字（但不推荐，会产生警告） 特性 C# C++ 默认行为 非虚拟 (方法默认不能被重写) 非虚拟 (方法默认不具有多态性) 实现多态 基类 virtual + 派生类 override 基类 virtual (派生类推荐使用 override) 设计哲学 “默认关闭”：出于安全和性能，需要显式开放重写能力。 “不为未使用的东西付出代价”：需要多态时，显式请求并承担其开销。 你的做法 慎重选择哪些方法设为virtual。只开放需要扩展的点。 必须为所有需要多态的方法加上virtual，否则无法按预期工作。 ","date":"27 August 2025","externalUrl":null,"permalink":"/Eric-s-Blog-v2/posts/1759232888597-post6/","section":"Posts","summary":"","title":"OODP2 里氏替换原则(LSP)","type":"posts"},{"content":" 软件实体应对拓展开放，对修改关闭 # 以规格模式为例 # 不好的写法 # public enum Color { Red, Green, Blue, } public enum Size { Small, Medium, Large, Yuge } public class Product { public string Name; public Color Color; public Size Size; public Product(string name, Color color, Size size) { if (name == null) { throw new ArgumentNullException(paramName: nameof(name)); } Name = name; Color = color; Size = size; } } 我们有一个产品类，上级需要我们使用size过滤产品，现在我们来做产品的过滤类\npublic class ProductFilter { public static IEnumerable\u0026lt;Product\u0026gt; FilterBySize(IEnumerable\u0026lt;Product\u0026gt; products, Size size) { foreach(var p in products) if (p.Size == size) yield return p; } } 注意到，如果上级又需要根据color过滤产品，我们又需要打开ProductFilter类，添加FilterByColor，而如果上级又需要我们同时根据color和size过滤产品，我们还需要再添加FilterByColorAndSize。\n如果Product有更多属性，这意味着我们需要反复的修改ProductFilter类，而该类可能已经交付了。因此这是一个非常不好的设计。\n规格模式 # 首先我们定义两个接口\npublic interface ISpecification\u0026lt;in T\u0026gt; { bool IsSatisfied(T t); } public interface IFilter\u0026lt;T\u0026gt; { IEnumerable\u0026lt;T\u0026gt; Filter(IEnumerable\u0026lt;T\u0026gt; items, ISpecification\u0026lt;T\u0026gt; spec); } 可以理解成ISpecification处理t是否满足某个条件，而IFilter返回传入的items中所有满足传入的spec规格的项目。\n那么此时Filter只要这样写，之后便可以固定住不再开放修改了。\npublic class BetterFilter : IFilter\u0026lt;Product\u0026gt; { public IEnumerable\u0026lt;Product\u0026gt; Filter(IEnumerable\u0026lt;Product\u0026gt; items, ISpecification\u0026lt;Product\u0026gt; spec) { foreach (var i in items) { if (spec.IsSatisfied(i)) { yield return i; } } } } 而基础的规格类也很简单\npublic class SizeSpecification(Size size) : ISpecification\u0026lt;Product\u0026gt; { public bool IsSatisfied(Product t) =\u0026gt; t.Size == size; } public class ColorSpecification(Color color) : ISpecification\u0026lt;Product\u0026gt; { public bool IsSatisfied(Product t) =\u0026gt; t.Color == color; } 如果我们需要规格的组合\npublic class AndSpecification\u0026lt;T\u0026gt;(ISpecification\u0026lt;T\u0026gt; first, ISpecification\u0026lt;T\u0026gt; second) : ISpecification\u0026lt;T\u0026gt; { private ISpecification\u0026lt;T\u0026gt; _first = first ?? throw new ArgumentNullException(paramName: nameof(first)), _second = second ?? throw new ArgumentNullException(paramName: nameof(second)); public bool IsSatisfied(T t) { return _first.IsSatisfied(t) \u0026amp;\u0026amp; _second.IsSatisfied(t); } } 只需要用AndSpecification将不同的Specification结合到一起生成新的Specification即可。\n注意到开发过程中BetterFilter类完全不需要修改，只需要拓展地多写几个实现ISpecification的规格类就可以完成功能的扩展。\n","date":"27 August 2025","externalUrl":null,"permalink":"/Eric-s-Blog-v2/posts/1759232882925-post5/","section":"Posts","summary":"","title":"OODP1 开闭原则(OCP)","type":"posts"},{"content":" 一个类应该仅有一个引起它变化的原因 # 实践上我遇到的问题是如何定义引起它变化的原因？是宏观的原因还是微观的原因？\n答案是宏观的 # Eric: 单一职责原则实践过程怎么把握，比如课程中说你要做一个Journal类来存入和查看日记，如果你又想要持久化它的话，不能直接在Journal类中写Save方法，而是要写一个新类Persistence来管理持久化。依据是一个类只能有一个引起他变化的原因。但是Journal类本身不也有存入和查看两个功能吗，两个功能变化时都要修改Journal类啊，这符合单一职责原则吗？难道要把存入和查看两个功能也分成两个类吗？具体实践中我们又要怎么把握呢？\nDeepseek的回答 # 1. 重新理解“引起变化的原因” # 单一职责原则（SRP）的核心不是“一个类只能有一个方法”，而是“一个类应该有且仅有一个引起它变化的原因”。\n这原因不是一个具体的功能，而是一个**高层级的、会变化的“轴”**或“关切点”。\nJournal类的职责：管理日记的核心业务逻辑（业务实体）。\n变化原因：当“日记”这个概念本身需要变化时，这个类才需要改变。 例子：我们需要为日记增加“标签”功能；我们需要修改日记的标题长度限制；我们需要在日记内容中支持Markdown格式。这些变化都围绕着“日记是什么、有什么行为”这个核心关切点。 “添加条目”和“查看条目” 都是对日记这个核心实体进行操作的核心行为。它们共享同一个变化原因——日记业务逻辑的变更。因此，它们属于同一个职责。 Persistence类的职责：处理数据的持久化机制（存储与读取）。\n变化原因：当数据存储的方式或位置发生变化时，这个类才需要改变。 例子：我们之前把日记保存到文本文件，现在想改成保存到MySQL数据库；我们想从本地存储改为云存储（如AWS S3）；我们想改变文件保存的格式（从JSON改为XML）。这些变化完全不影响Journal类本身是什么，它只关心“怎么存、存到哪里”。 2. 为什么不能把Save方法放在Journal里？ # 如果将Save方法直接放在Journal类中，就意味着这个类现在有两个引起它变化的原因：\n日记的业务逻辑变化（如增加标签）。 持久化机制的变化（如从文件存到数据库）。 这违反了SRP。带来的直接问题是：\n可维护性差：一个负责数据库连接的开发人员修改了Save方法，可能会意外影响到另一个只关心业务逻辑（如addEntry方法）的开发人员。 复用性差：如果你想重用Journal这个业务实体，但新的项目想用不同的存储方式（比如内存存储），你就必须把Journal类也拖过去，并附带一堆你可能不需要的文件I/O代码。 测试困难：测试Journal的业务逻辑时，你必须绕过或模拟（Mock）文件系统操作，使得单元测试变得复杂。 而通过引入Persistence类，你将变化隔离了。Journal的变更和Persistence的变更互不影响。你可以轻松地替换不同的持久化策略而不影响核心业务代码。\n3. 实践中如何把握这个“度”？（关键部分） # 这是一个设计权衡的艺术，没有绝对正确的答案，但有一些非常实用的指导原则：\na. 关注“变化轴”，而非功能数量 # 不要简单地数一个类有多少个方法。而要问自己：“哪些变化会迫使这个类被修改？”。如果所有方法都因为同一个宏观原因而变化，那它们很可能属于同一个职责。\nJournal的例子：addEntry和removeEntry都围绕着“管理条目生命周期”这个轴。 另一个例子：一个User类有login、logout、changePassword方法。它们都围绕着“用户身份认证”这个轴。但如果把“发送营销邮件sendPromotionalEmail”也塞进User类，那就不对了，因为那属于“通知”或“营销”这个不同的变化轴。 b. 应用“共同闭包原则”（CCP） # 这是包级别的一个原则，但同样适用于类设计：将那些同时、因同样原因而变化的东西放在一起。\nJournal里的方法总是因为日记业务的变化而一起改变。 Persistence类里的方法总是因为存储技术的变化而一起改变。 但它们两者之间几乎不会因为对方的原因而改变。所以它们应该被分开。 c. 从“角色”和“用户”视角思考 # 想象一下谁会要求这个类做出改变。\n产品经理可能会要求改变Journal：“我们需要给日记加个心情图标”。 运维工程师可能会要求改变Persistence：“数据库要从MySQL迁移到PostgreSQL，连接字符串和方言要改”。 如果来自完全不同角色、不同关切方的需求会迫使你修改同一个类，那么这个类很可能承担了多个职责。\nd. 避免过早优化和过度设计 # 在项目早期，如果持久化方式非常稳定（比如确定就用一个简单的JSON文件），并且项目很小，那么稍微违反一下SRP的代价可能低于引入一个新类的复杂度。一开始可以放在一起，但要有意识地将实现细节隐藏好（比如用private方法），并在第一次需要变化时（比如要加第二种存储方式）果断进行重构，将其提取到独立的类中。\n总结 # Journal类的“存入”和“查看”：属于对同一业务实体（日记）的操作，是同一个职责，变化原因相同，因此放在一个类是合理的，符合SRP。 Journal类的“Save”方法：属于另一个职责（持久化），变化原因不同（业务逻辑 vs. 存储技术），因此应该拆分成Persistence类。 实践心法： 聚焦于 “变化的原因” ，而不是方法的数量。 思考 “谁会要求它改变”（产品经理 vs. 运维）。 遵循 “共同闭包原则”——因同样原因而变化的东西放在一起。 循序渐进，在简单和设计之间权衡，在代码第一次发出“臭味”（难以修改、难以测试）时果断重构。 ","date":"27 August 2025","externalUrl":null,"permalink":"/Eric-s-Blog-v2/posts/1759232878687-post4/","section":"Posts","summary":"","title":"OODP0 单一职责原则(SRP)","type":"posts"},{"content":"","date":"20 August 2025","externalUrl":null,"permalink":"/Eric-s-Blog-v2/tags/cpp/","section":"Tags","summary":"","title":"Cpp","type":"tags"},{"content":" 背景 # 两个月前看了一点Effective Modern Cpp，后来听说作者Scott Mayer写了三本书，Cpp三部曲(E C, More E C, E Modern C)。于是搁置了Effective Modern Cpp，转而去看Effective Cpp。当时看到作者的一个观点是函数返回值优先const 即优先写\nconst std::string func()... 而不是\nstd::string func()... 原因是有人会在if语句里做判断，发生typo，将判断写成赋值 如\nMatrix64 a, b, c; ... if (a * b = c){ // should be \u0026#34;==\u0026#34; } 若*的重载函数返回const Matrix64，编译器就会报错，否则就难以找到错误发生的地方。 听起来非常有道理，于是书上说\n一个函数返回一个 constant value（常量值），常常可以在不放弃安全和效率的前提下尽可能减少客户的错误造成的影响。\n然而今天机缘巧合之下我去问dicksip我们是不是应该在cpp的函数返回值上默认const，它却给出了否定的答案。 其实原因也非常简单，只是我之前没有去想\n为什么我们不应该广泛使用const返回值? # 原因1 降低性能(阻止移动语义,RVO,NRVO) # 在现代cpp中，函数返回值const会影响移动语义，移动语义需要非常量右值 在没有const的情况下\nData getData(){ Data data; ... return data; } Data receiver = getData();// 触发移动语义，甚至RVO,NRVO // 如果 // const Data getData(); // 则只能触发拷贝。 原因2 阻碍现代范式 # 如\n链式调用(Fluent Interface) # class MyString{ public: MyString\u0026amp; toUpper(); } proccessString.toUpper();//没有const时才能写 就地操作 # void modifyValue(std::string\u0026amp;\u0026amp; str); modifyValue(getValue()) //高效接受右值处理 一种惯用法 # // 从流中读取数据并检查是否成功 if (std::cin \u0026gt;\u0026gt; value) { ... } // 在循环中获取锁并检查是否成功 while (std::unique_lock lock(mutex, std::try_to_lock)) { ... } // 获取一个资源指针并检查是否有效 if (auto ptr = acquireResource()) { ... } 这里unique_ptr和unique_lock等都必须接受非常量右值，如果const就无法构造。\n原因3 更好的现代方案 # 原先这种写法解决的问题在今天已经不是问题，现代编译器都可以对if(),while()等中出现的异常赋值操作发出Warning 我们没有必要为了有限的好处牺牲掉众多现代cpp的优秀特性，那显然是因噎废食。\n原因4 一致性原则 # cpp标准库没有那样做，我们应该与cpp标准库保持一致\n什么时候应该用const返回值? # 返回引用和指针时，如果不希望被修改内部数据，必须使用const返回值， 此处较为简单，省略\n总结 # 我不想说什么“我们应该在读书的时候多加思考”之类的废话。很多时候，我们就是没有办法想到那些东西，才会陷入歧途。所以与其说我们要多思考，不如讲我们可以从哪些方面思考。\n1. 考虑书的时代性 # Effective Cpp这本书是Scott Mayer三部曲中的第一本，初版于1991年。这个时间就注定这本书很难完全适用今天的C++23(甚至2c)时代，时过境迁，我们在计算机这样的火热领域，看到如此之大的年代差别时，就应该对书的内容保持较大的警惕了。\n2. 考虑自己的经验 # 虽然很多时候很多学科确实会冲击我们的经验，如离散数学，概率论，实分析中很多内容(比如0-1间有理数的测度为0)都和经验相悖，这些实实在在地让我们这样的工科大学生渐渐放弃了我们的经验。然而当理论和经验发生冲突时，进行一个彻底的探究，来搞清楚孰对孰错也是件很要紧的事。如果是经验错了，比起放弃经验和直觉，我们更重要的是培养正确的新的经验和直觉，对我们直觉所依赖的东西进行一个彻底的修复，将错的感觉清楚，正确的理论形成直觉，这才是求实的态度。\n当我们看到返回值应该const这样激进的言论的时候，我们要去质疑，毕竟值优先const是很常见的说法，而返回值const则很少见了。在我们平时阅读的开源代码中，将返回值const的写法也是极其罕见的。种种迹象表明，这一个item是极其有悖于常识的。\n3. 实践出真知 # 在足够多，足够严谨的工程实践中，我们会找到正确的答案，一切不合适的理论自然会不攻自破，所以多参与工程一定是好的。\n","date":"20 August 2025","externalUrl":null,"permalink":"/Eric-s-Blog-v2/posts/1759232872971-post3/","section":"Posts","summary":"","title":"关于cpp中const返回值","type":"posts"},{"content":"","date":"16 July 2025","externalUrl":null,"permalink":"/Eric-s-Blog-v2/tags/%E5%A4%8F%E5%87%A0%E6%8A%8A%E6%83%B3/","section":"Tags","summary":"","title":"夏几把想","type":"tags"},{"content":"非常抱歉总是在博客里写废话，但是生活的轨迹总是偏离我的计划，于是悲伤和懊恼就随之而来。\n有时候就是不想做任何事，然后又因为无事可做感到无聊 # 昨天想的那个todo项目，我在构思以后想到这个todo项目本质上是想做成一个大型项目管理软件，核心功能包括有基础的todo(blocking, todo, doing, submitted, passed)等状态，需要设计一个数据库，有todo的待办状态，todo的内容，todo的关联项目，直接负责人，审批人等属性。与此同时，需要设计一个权限系统，用户自定义role，决定每个role的可视范围和管理范围等。图形功能上，我本来使用qt来完成，后面又看到大部分此类系统实际上使用前端react或vue来完成。本着先设计核心模块的想法，我又想也许可以先做一个cli工具出来。但是核心模块上我又没有学习qsqlquery和qsqldatabase。qsqldatabase的设计思路实际上和传统orm不同。所以这个项目目前还得继续构思。\n然后呢，下午看了一会vulkan，又感觉没意思了。打开cs144，也不想看。这时候打开了qq空间，看到一些动态，想起了以前的一些事，心弦扰动，这时候我的心情就更低落了。 过了一会看了一眼大班群，发现有个辅导员发了一个专业的绩点，我又想起来这学期堪称灾难的期末考试，几乎每一门我用心了的课都炸了。 然后我又想起来数模的期末考核，我那个逆天组队，队长和另一个队友都摆烂了。\n悲伤有时候像潮水，所有的烦心事像一场发生在海面上的风暴，掀起一波又一波巨浪 # 也许生活不全是悲伤 # 就在我写这篇博客时，队长联系我说他决定放弃了，所以数模小组原地解散，在最后考核的时候。所以今年的数模也与我无缘了。\n但我没有觉得悲哀，反而觉得释怀。\n我就是这样一种人，我能接受事情做不成，但不能接受拖着，我会觉得我应该做点什么，可是事实是我什么都做不了，这种感觉最令人煎熬。\n","date":"16 July 2025","externalUrl":null,"permalink":"/Eric-s-Blog-v2/posts/1759232865935-post2/","section":"Posts","summary":"","title":"我的痛苦1","type":"posts"},{"content":"","date":"16 July 2025","externalUrl":null,"permalink":"/Eric-s-Blog-v2/categories/%E7%94%9F%E6%B4%BB%E7%9B%B8%E5%85%B3/","section":"Categories","summary":"","title":"生活相关","type":"categories"},{"content":"","date":"15 July 2025","externalUrl":null,"permalink":"/Eric-s-Blog-v2/categories/%E6%83%B3%E6%B3%95%E6%9E%84%E6%80%9D/","section":"Categories","summary":"","title":"想法构思","type":"categories"},{"content":"故事大概就是我突然想做一个todo类软件，在我和deepseek切磋了创新点，功能点等之后，deepseek给出了如下不明觉厉的项目规划说明书\n智能任务协同管理平台需求规格说明书 # 文档编号：TDMS-RS-2025-v1.2\n发布日期：2025年7月15日\n1. 系统概述 # 开发基于Qt/C++与SQLite/PostgreSQL的跨平台任务管理系统，集成AI增强能力，支持个人至团队级任务管理，实现任务规划→执行监控→知识沉淀→智能进化的全生命周期管理。\n2. 功能需求 # 2.1 核心任务管理模块 # 功能编号 需求描述 技术实现要点 TD-0100 多视图任务展示 QTabWidget + QStackedWidget - 看板视图（Kanban） QGraphicsView拖拽泳道 - 时间线视图（Gantt） QCustomPlot动态图表 - 列表视图/树状视图 QTreeView + QStandardItemModel TD-0200 任务元素管理 数据库关系设计 - 任务属性：标题/描述/优先级/标签 SQLite BLOB存储富文本 - 子任务分解（无限层级） 邻接表结构存储 - 附件管理（文档/图片/链接） QFileSystemWatcher监控目录 TD-0300 智能提醒系统 QCalendarWidget集成 - 时间提醒（绝对/相对时间） 基于cron表达式解析器 - 位置提醒（GPS触发） QtPositioning模块 - 设备状态提醒（空闲时推送） QSystemIdleDetector 2.2 协同工作模块 # 功能编号 需求描述 技术实现要点 CL-0100 团队空间管理 OAuth2.0认证体系 - 角色权限控制（所有者/编辑者/查看者） RBAC模型数据库设计 - 项目空间隔离 SQLite ATTACH DATABASE CL-0200 实时协作功能 WebSocket + Operational Transform - 任务分配与@提及通知 QNetworkSession管理连接 - 协同编辑冲突解决 CRDT算法实现 - 版本历史追溯（可回滚） SQLite时间旅行扩展 CL-0300 沟通集成 libcurl网络库 - 评论线程（Markdown支持） QTextDocument解析 - 邮件同步（任务变更通知） SMTP协议实现 2.3 AI增强模块 # 功能编号 需求描述 技术实现要点 AI-0100 自然语言任务解析 ONNX运行时本地推理 - 任务语义解构（提取实体/关系） 微调BERT模型（\u0026lt;50MB） - 自动生成子任务树 决策树算法生成 AI-0200 动态规划引擎 QtConcurrent并行计算 - 时间预估（基于历史效率分析） ARIMA时间序列预测 - 智能排程（资源冲突检测） 约束满足问题求解器 - 风险预警（关键路径标识） 图论算法应用 AI-0300 知识增强系统 DuckDB向量数据库 - 任务关联文档推荐 Sentence-BERT相似度匹配 - 代码片段自动生成（开发任务） OpenAI Codex本地化模型 2.4 分析预测模块 # 功能编号 需求描述 技术实现要点 AN-0100 生产力分析 QtCharts数据可视化 - 个人效能热力图（专注时段分析） QSensor数据采集 - 团队负载均衡图 力导向图算法 AN-0200 预测性报告 SQL窗口函数分析 - 项目完成概率预测 蒙特卡洛模拟 - 延期风险指数计算 逻辑回归模型 3. 非功能性需求 # 3.1 性能需求 # gantt title 关键性能指标 dateFormat YYYY-MM-DD section 响应时间 任务加载(1000条) ：active, p1, 2025-08-01, 1.2s AI解析响应(P95) ： p2, after p1, 0.8s 协同操作同步 ： p3, after p2, 0.3s section 资源占用 内存常驻 ：crit, 2025-08-01, 120MB 存储压缩比 ： \u0026gt;=5:1 3.2 安全需求 # 数据加密：SQLite页级AES-256加密（SQLCipher扩展） 隐私保护：AI处理本地化（可选关闭云同步） 审计追踪：操作日志HMAC-SHA256签名 3.3 可靠性需求 # 崩溃恢复：自动保存点（15分钟增量备份） 冲突解决：三阶段协同冲突处理策略： 客户端自动合并（基于CRDT） 用户决策界面（可视化差异对比） 版本分支存档 3.4 兼容性需求 # 平台 支持级别 技术方案 Windows 完整功能 MSVC 2022编译 macOS 完整功能+原生UI Qt for macOS Linux 完整功能 Wayland/X11双支持 Android 核心功能 Qt 6.5 Mobile模块 Web 只读视图 WebAssembly编译 4. 系统架构 # 4.1 逻辑架构 # +-----------------------+ | Presentation | | QWidgets / QtQuick | +----------+------------+ | (信号槽) +----------v------------+ | Business Logic | | - 任务管理核心 | | - AI推理引擎 | | - 协同控制器 | +----------+------------+ | (DAO接口) +----------v------------+ | Data Layer | | - SQLite OLTP | | - DuckDB OLAP | | - 模型文件存储 | +-----------------------+ 4.2 部署架构 # graph TD A[桌面客户端] --\u0026gt; B[本地数据库] A --\u0026gt; C[AI模型仓库] A \u0026lt;--\u0026gt; D[协同服务器] D --\u0026gt; E[(PostgreSQL集群)] D --\u0026gt; F[Redis实时队列] G[移动端] --\u0026gt; D H[Web端] --\u0026gt; D 5. AI集成方案 # 5.1 智能规划工作流 # sequenceDiagram participant User participant UI participant AI Engine participant Database User-\u0026gt;\u0026gt;UI： 输入“开发邮件客户端，需加密模块，两周完成” UI-\u0026gt;\u0026gt;AI Engine： 发送自然语言请求 AI Engine-\u0026gt;\u0026gt;AI Engine： 实体识别（技术栈/时间/功能） AI Engine-\u0026gt;\u0026gt;Database： 查询相似任务历史数据 Database--\u0026gt;\u0026gt;AI Engine： 返回历史执行指标 AI Engine-\u0026gt;\u0026gt;AI Engine： 生成任务分解树 AI Engine-\u0026gt;\u0026gt;UI： 返回结构化规划： • 子任务：UI框架/认证模块/加密集成 • 时间线：甘特图+风险提示 UI-\u0026gt;\u0026gt;User： 可视化展示可编辑方案 5.2 关键技术实现 # // AI任务解析核心类 class TaskParser : public QObject { Q_OBJECT public: explicit TaskParser(QObject *parent = nullptr); Q_INVOKABLE ParsedTask parseDescription(const QString \u0026amp;text); private: // ONNX推理引擎 Ort::Session *nlpSession; // 本地知识图谱 DuckDBConnection *knowledgeGraph; }; // 返回数据结构 struct ParsedTask { QString title; QVector\u0026lt;Subtask\u0026gt; subtasks; QMap\u0026lt;QString, QTime\u0026gt; timeEstimates; QVector\u0026lt;KnowledgeLink\u0026gt; relatedResources; }; 6. 交付物规划 # 6.1 阶段化交付 # 迭代 功能集 AI能力 周期 MVP 基础任务管理+本地AI解析 L1：关键词提取 8周 v1.0 团队协同+动态规划 L2：时间预估 12周 v1.5 预测分析+跨平台 L3：风险建模 6周 v2.0 AR集成+企业级扩展 L4：自适应工作流 10周 6.2 质量保障 # 自动化测试覆盖率： 核心逻辑：≥85%（QTest框架） UI交互：≥70%（Squish自动化） AI模型评估： 任务分解准确率：F1-score ≥0.82 时间预估误差：MAPE ≤15% 7. 创新价值矩阵 # quadrantChart title 功能价值分析 x-axis 开发成本 → y-axis 用户价值 ↑ quadrant-1 战略核心 quadrant-2 差异化优势 quadrant-3 基础必备 quadrant-4 优化选项 “动态AI规划”： [0.7, 0.95] “协同冲突解决”： [0.6, 0.8] “多视图看板”： [0.3, 0.9] “知识图谱”： [0.65, 0.7] “AR集成”： [0.85, 0.6] 本需求书完整涵盖传统任务管理核心功能（看板/协同/提醒）与AI创新点（智能规划/预测分析），建议采用模块化开发策略：\n基础框架搭建：实现TD-0100/TD-0200模块（4周） 协同核心开发：完成CL系列功能（6周） AI引擎集成：部署AI-0100/AI-0200（8周） 分析预测扩展：构建AN模块（4周） 具体内容我觉得非常好，所以打算朝这个方向做，虽然很明显我做不成很厉害的样子但至少可以做着玩玩。\n起手 # 我肯定不愿意用qt原生的组件，因为太丑，自己搓组件又太麻烦，所以我干脆上网找开源项目。有一个QFluentWidget的项目，但是它的cpp的版本要几千块钱买，所以我只好放弃。后面找到了ElaWidgetTools，今天下午刚配好ElaWidgetTools，预计后面以ElaWidgetTools作为主要UI库。 目前项目刚刚开始，希望我不要又做成一坨。\n","date":"15 July 2025","externalUrl":null,"permalink":"/Eric-s-Blog-v2/posts/1759232853936-post1/","section":"Posts","summary":"","title":"构想一个智能todo项目进度管理软件","type":"posts"},{"content":"","date":"15 July 2025","externalUrl":null,"permalink":"/Eric-s-Blog-v2/tags/%E6%B2%A1%E6%9C%89%E5%AE%8C%E6%88%90/","section":"Tags","summary":"","title":"没有完成","type":"tags"},{"content":"这是博客的介绍，同时也是该博客的第一篇文章。\n关于Eric # 专业 # Eric是一名即将大一升大二的计算机相关专业大学牲，Eric主要喜欢Cpp，看过极少量的Effective Cpp，Effective Modern Cpp等Cpp相关的书籍，用Qt做过一个简单的地图渲染和表达式解析（调包）与路径规划的程序，但是其架构过于SHXT（命名不规范，经常父类转子类，架构的设计一开始就烂完了），所以Eric不推荐任何人去看这个项目。同时Eric学习了基础的Unreal Engine的皮毛（至少会建立项目，能分清Controller,Pawn,Actor，以及基本上会在开发里应用接口和组件。也大致会用蓝图和cpp交互）并且也中途放弃:(。\n与此同时Eric对rust等特性独特的语言感兴趣，在了解过rust基本语法后三次学习bevy并且都中途放弃（\u0026hellip;）。\nEric对计算机底层很感兴趣，自学了CSAPP前三章（事实上第三章学了一学期了，汇编真是让人很没有看的欲望），CS61B，基础的acm算法内容。\nEric对前端vue等有最基础的理解。\nEric曾经用Java+Springboot+Hibernate+JSP做过一个增删改查的图书馆订阅系统（大一上选的OODP公选课期末大作业，所以技术栈极其古老\u0026hellip;）。\nEric目前主要推进学习CS144和psql,CMU15445。\nEric是一个没有梦想的咸鱼。对他而言，一千万和一个亿是没有区别的，只要正常的物质需求能满足，就只有精神是需要考虑的。他的偶像是Linus和Carmack，Eric希望能成为一名技术大牛，站在CS某个子领域的顶点。\n爱好 # Eric最喜欢的颜色是黑色和白色，虽然他觉得自己的灵魂是深蓝色。\nEric喜欢的音乐类型有hiphop,jazz,rnb,rocknroll等等。\nEric最喜欢的事情是折腾有意思的事情（关于CS）和睡觉。\nEric喜欢当咸鱼，他讨厌内卷，他喜欢浪漫的追求，至少他认为人如果只是为了赚钱或者是换取某种名声而努力是很无聊的。当金钱已经足够生活，更多的钱只会滋生低级趣味。虽然Eric承认也许有一天他也会变得很可悲，不得不为了生计放弃操守，但那至少不是现在，今天他仍然是一个无忧无虑的大学生。\nEric有点想去墓地工作，看守墓园，他认为这是一件很浪漫的事。虽然他其实很胆小，连恐怖游戏都不敢玩。\n性格 # Eric的性格并不好。他的mbti是intj。但这不重要，重要的是他比较内向，但他并不是不敢说话，他只是不喜欢跟不熟悉的人说话。\nEric的性格非常急躁，不过好在他内心重视的事不多，所以他的急躁很少表现出来，其他人往往以为他脾气很好。\nEric有时有意的减少自己的存在感，因为他觉得这样当别人开始了解他时会更惊喜。显然并没有人想要了解他，于是这故事显得有些孤独。总之结果就是班里认识他的人很多，但是大家对他的了解很少（虽然其实大学班级本来就比较生疏）。\n关于该博客 # 该博客是Eric花了半天时间研究hugo,github.io部署和找hugo主题折腾出来的。 实际上主要难点在hugo主题上，试了好几个主题，有的是主题太老，使用了不支持的包，总之历经千辛万苦（并非），Eric找到了PaperMod这个主题，符合简约的风格并且配置非常简单，Eric非常感谢PaperMod项目。\n该博客以后会随缘更新各种技术相关和技术不相关的内容（废话？），也可能一直不更新，不更新就是Eric在睡觉。\n推荐链接 # Eric的bilibili\nEric的Github\nPaperMod官网\nspiderboy的博客\nSonnyCalcr的博客(提供了博客创建教程)\n","date":"14 July 2025","externalUrl":null,"permalink":"/Eric-s-Blog-v2/posts/about/","section":"Posts","summary":"","title":"about","type":"posts"},{"content":"","date":"14 July 2025","externalUrl":null,"permalink":"/Eric-s-Blog-v2/categories/%E7%94%9F%E6%B4%BB/","section":"Categories","summary":"","title":"生活","type":"categories"},{"content":"","date":"14 July 2025","externalUrl":null,"permalink":"/Eric-s-Blog-v2/tags/%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D/","section":"Tags","summary":"","title":"自我介绍","type":"tags"},{"content":"","externalUrl":null,"permalink":"/Eric-s-Blog-v2/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/Eric-s-Blog-v2/series/","section":"Series","summary":"","title":"Series","type":"series"}]